# 最长公共子序列 (Longest Common Subsequence, LCS)

给出 $1,2,\ldots,n$ 的两个排列 $P_1$ 和 $P_2$ ，求它们的最长公共子序列。

## $O(n^2)$的做法

`dp[i][j]`：表示$P_1$截止到第$i$个数之后，$P_2$截止到第$j$个数之后，此时的LCS长度

```
          i     j
* * * * * 3 * * *
* * * * * * * * 3
```

```
          i     j
* * * * * 4 * * *
* * * * * * * 4 3
dp[i][j] = dp[i][j-1]
```

```
          i     j
* * * * 3 4 * * *
* * * * * * * * 3 
dp[i][j] = dp[i-1][j]
```

```
          i     j
* * * * 2 4 * * *
* * * * * * * 2 3 
dp[i][j] = dp[i-1][j]
```

```cpp
for(int i = 1; i <= n; i++)
    for(int j = 1; j <= n; j++){
        if(p1[i] == p2[j]) dp[i][j] = dp[i-1][j-1] + 1;
        else dp[i][j] = max(dp[i][j-1], dp[i-1][j]);
    }
// 答案就是dp[n][m]
```

## $O(n\log n)$的做法

一个特殊的例子

```
1 2 3 4 5 6 7 8
3 5 6 1 2 4 8 7
```

$P_1$的子序列一定是上升子序列

反过来，上升子序列一定是$P_1$的子序列

所以只要求$P_2$的LIS

如果一般一点呢？

```
5 2 3 4 1 6
1 5 2 3 4 6
```

原本答案应该是5，LCS是 `5 2 3 4 6`，假如交换第1个和第5个位置

```
1 2 3 4 5 6
4 5 2 3 1 6
```

这时候答案不对了，这时候答案是3，所以不能随意交换。但也是转化为LIS

```
1 2 3 4 5 6
a b c d e f
5 2 3 4 1 6

1 5 2 3 4 6
e a b c d f
5 1 2 3 4 6
```

最后就是求$P_2$的对应序列的LIS，如何求得$P_2$的对应序列？

```cpp
for(int i = 1; i <= n; i++){
    cin >> p1[i];
    tmp[p1[i]] = i;
    // tmp[a]=b 表示 原序列中的a 对应到对应序列的b
}
for(int i = 1; i <= n; i++){
    cin >> p2[i];
    p2d[i] = tmp[p2[i]];
}
// 最后求 p2d[] 的LIS
```