## 01背包

$n$个物品，每个物品有一个体积$v_i$，有一个价值$w_i$，你有一个背包，容积为$M$。选择一些物品，使得体积之和不超过背包容积，并且价值之和最大（都是正整数）

$O(nM)$

`dp[i][j]`表示：现在考虑了前$i$个物品，当前体积之和为$j$，最大的价值

`dp[n][1,...,M]`的最大值就是答案

`dp[1][ v[1] ] = w[1]`

`dp[2][ v[1] ] = w[1]`, `dp[2][ v[2] ] = w[2]`, `dp[2][v[1]+v[2]]=w[1]+w[2]`

考虑加入第$i+1$个物品，加入后的总体积为$j$：

`dp[i+1][j] = max(dp[i][j], dp[i][j-v[i+1]])`：$j$从$1$到$M$枚举

`dp[i-1][...]`：是没用的

```cpp
dp[1][v[1]]=w[1];
for(int i = 1; i < n; i++)
    for(int j = 0; j <= M; j++)
        // j枚举的是考虑完第i+1个物品后的总体积
        // dp[i+1][j]表示：考虑完第i+1个物品之后，总体积为j，此时的最大价值
        // dp[i][k]表示：考虑第i+1个物品之前，总体积为k，此时的最大价值
        // 第一项：第i+1个物品不选，总体积为j，那么考虑完第i个物品之后，总体积也是j
        // 第二项：第i+1个物品选，总体积为j，那么考虑完第i个物品之后(也就是考虑第i+1个物品之前)，总体积应该是j-v[i+1]
        if(j<v[i+1]) dp[i+1][j] = dp[i][j];
        else dp[i+1][j] = max(dp[i][j], dp[i][j-v[i+1]]+w[i+1]);
```
改为：`fdp[2][M]`，轮着用

`dp[1][...]` 存到 `fdp[0][...]`里

`dp[2][...]` 存到 `fdp[1][...]`里

计算`dp[3][...]`，此时`dp[1][...]`没用，我们就把`dp[3][...]` 存到 `fdp[0][...]`里


### 优化

使用`f[M]`

```
 dp[i][...]:    Q Q ! Q Q Q ! # # # # #
 dp[i+1][...]:  P P P P P P j P P P P P
```

从前往后：

```cpp
f[v[1]] = w[1];
for(int i = 1; i < n; i++)
    for(int j = 0; j <= M; j++){
        // f[j+1,j+2,...,M] 目前表示 dp[i][j+1,j+2,...,M]
        // f[0,...,j] 表示的是 dp[i+1][0,...,j]
        // 现在让 f[j] 表示 dp[i+1][j]
        if(j<v[i+1]) f[j] = f[j];
        else f[j] = max(f[j], f[j-v[i+1]]+w[i+1]); // 错误！
    }
```

必须从后往前：

```cpp
f[v[1]] = w[1];
for(int i = 1; i < n; i++)
    for(int j = M; j >= 0; j--){
        // f[j+1,j+2,...,M] 目前表示 dp[i+1][j+1,j+2,...,M]
        // f[0,...,j] 目前表示 dp[i][0,...,j]
        // 现在让 f[j] 表示 dp[i+1][j]
        if(j<v[i+1]) f[j] = f[j];
        else f[j] = max(f[j], f[j-v[i+1]]+w[i+1]);
    }
```

简化为：

```cpp
f[v[1]] = w[1];
for(int i = 1; i < n; i++)
    for(int j = M; j >= v[i+1]; j--){
        // f[j+1,j+2,...,M] 目前表示 dp[i+1][j+1,j+2,...,M]
        // f[0,...,j] 目前表示 dp[i][0,...,j]
        // 现在让 f[j] 表示 dp[i+1][j]
        f[j] = max(f[j], f[j-v[i+1]]+w[i+1]);
    }
```

## 完全背包

$n$种物品，每种物品有一个体积$v_i$，有一个价值$w_i$，每种物品有无限多个。你有一个背包，容积为$M$。选择一些物品，使得体积之和不超过背包容积，并且价值之和最大（都是正整数）

$O(nM)$

`dp[i][j]`表示：现在考虑了前$i$种物品，当前体积之和为$j$，最大的价值

```cpp
dp[1][v[1]]=w[1];
for(int i = 1; i < n; i++){
    for(int j = 0; j <= M; j++){
        // j表示选完第i+1种物品之后的总体积
        int tmp = dp[i][j];
        if(j<v[i+1]) dp[i+1][j] = tmp;
        for(int k = 1; k <= j/v[i+1]; k++){
            // k表示第i+1种物品选几个
            tmp = max(tmp, dp[i][j-k*v[i+1]]+k*w[i+1]);
        }
        dp[i+1][j] = tmp;
    }
}
```

### 优化

```cpp
`dp[i][j]`表示：现在考虑了前$i$种物品，当前体积之和不超过$j$，最大的价值
for(int i = 0; i < n; i++){
    for(int j = v[i+1]; j <= M; j++){
        // j表示选完第i+1种物品之后的总体积
        // dp[i+1][1,...,j-1]的值已经更新过了
        dp[i+1][j] = max(dp[i][j], dp[i+1][j-v[i+1]] + w[i+1]);
    }
}
```

### 再优化

必须从前往后

```cpp
memset(f, -1, sizeof(f));
// f[j]=-1 表示目前为止（考虑到第i个物品为止）体积为j是凑不出来的
f[0] = 0;
for(int i = 0; i < n; i++){
    for(int j = v[i+1]; j <= M; j++){
        // j表示选完第i+1种物品之后的总体积
        // dp[i+1][1,...,j-1]的值已经更新过了
        // f[1,...,j-1] 表示 dp[i+1][1,...,j-1]
        // f[j,...,M] 表示 dp[i][j,...,M]
        // 现在要让 f[j] 表示 dp[i+1][j]
        if(f[j-v[i+1]] != -1) f[j] = max(f[j], f[j-v[i+1]] + w[i+1]);
    }
}
```

```
v[1]=2, w[1]=5
v[2]=3, w[2]=7

i=0
     0   1   2   3,   4,    5,   6
f = {0, -1,  5,  -1,  10,  -1,   15  }

i=1
     0   1   2   3,   4
f = {0, -1,  5,  7,   10}
```

很好！

还能更好！

`dp[i][j]`表示：现在考虑了前$i$种物品，当前体积之和不超过$j$，最大的价值

```cpp
for(int i = 0; i < n; i++){
    for(int j = v[i+1]; j <= M; j++){
        // j表示选完第i+1种物品之后不能超过的的总体积
        // dp[i+1][1,...,j-1]的值已经更新过了
        // f[1,...,j-1] 表示 dp[i+1][1,...,j-1]
        // f[j,...,M] 表示 dp[i][j,...,M]
        // 现在要让 f[j] 表示 dp[i+1][j]
        f[j] = max(f[j], f[j-v[i+1]] + w[i+1]);
    }
}
```

```
v[1]=2, w[1]=5
v[2]=3, w[2]=7

i=0
     0    1    2    3    4    5    6    7  ...
f=   0    0    5    5    10   10   15   15 ...

i=1
     0    1    2    3    4    5     6     7  ...
f=   0    0    5    7    10   12    15    17 ...
```

最后直接输出`f[M]`就可以了

## P1757

`dp[s][j]`：表示只使用前$s$组的物品，总体积不超过$j$时，最大的价值之和

结构体排序

```cpp
struct Obj{
    // a:体积，b:价值，c:组号
    int a, b, c;
} ob[1005];
int n, m, k;

bool cmp(Obj x, Obj y){
    return x.c < y.c;
}

int main(){
    sort(ob+1, ob+n+1, cmp);
}
```

计算出`l[i]`表示第$i$组的第一个物品的下标（排序后的）

有一点小坑

现在考虑第$i$组

```cpp
// k表示一共有几组
for(int i = 1; i <= k; i++){
    for(int j = 0; j <= m; j++){
        // dp[i-1][j]：表示只使用前i-1组的物品，总体积不超过j时，最大的价值之和
        dp[i][j] = dp[i-1][j];
        for(int p = l[i]; p < l[i+1]; p++){
            dp[i][j] = max(dp[i][j], dp[i][j-ob[p].a] + ob[p].b);
        }
    }
}
```

## 部分背包（不讲）