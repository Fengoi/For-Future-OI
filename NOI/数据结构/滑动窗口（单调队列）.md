# 滑动窗口（单调队列）

## 题目描述

### 模板传送

- [P1886](https://www.luogu.com.cn/problem/P1886)

### 问题描述

有一个长为 $n$ 的序列 $a$，以及一个大小为 $k$ 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。

例如，对于序列 $[1,3,-1,-3,5,3,6,7]$ 以及 $k = 3$，有如下过程：

$$\def\arraystretch{1.2}
\begin{array}{|c|c|c|}\hline
\textsf{窗口位置} & \textsf{最小值} & \textsf{最大值} \\ \hline
\verb![1   3  -1] -3   5   3   6   7 ! & -1 & 3 \\ \hline
\verb! 1  [3  -1  -3]  5   3   6   7 ! & -3 & 3 \\ \hline
\verb! 1   3 [-1  -3   5]  3   6   7 ! & -3 & 5 \\ \hline
\verb! 1   3  -1 [-3   5   3]  6   7 ! & -3 & 5 \\ \hline
\verb! 1   3  -1  -3  [5   3   6]  7 ! & 3 & 6 \\ \hline
\verb! 1   3  -1  -3   5  [3   6   7]! & 3 & 7 \\ \hline
\end{array}
$$

## 分析

### Define

单调队列有两个性质：

1. 队列中的元素其对应在原来的列表中的顺序必须是单调递增的。
2. 队列中元素的大小必须是单调递*（增 / 减 / 甚至是自定义也可以）

> 单调队列与普通队列不一样的地方就在于单调队列既可以从 **队首出队**，也可以从**队尾出队**。

### Achieve

就拿样例来谈谈，设以最小的为标准。

> 8 3  
> 1 3 -1 -3 5 3 6 7

下文中我们用 $q$ 来表示单调队列，$p$ 来表示其所对应的在原列表里的序号。

1. 由于此时队中没有一个元素，我们直接令 $1$ 进队。此时，`q = {1}`,`p = {1}`。  
   
2. 现在 $3$ 面临着抉择。下面基于这样一个思想:假如把 $3$ 放进去，如果后面 $2$ 个数都比它大，那么 $3$ 在其有生之年就有可能成为最小的。此时，`q = {1,3}`,`p = {1,2}`。
   
3. 下面出现了 $-1$。队尾元素 $3$ 比 $-1$ 大，那么意味着只要 $-1$进队，那么 $3$ 在其有生之年必定成为不了最小值，原因很明显:因为当下面 $3$ 被框起来，那么 $-1$ 也一定被框起来，所以 $3$ 永远不能当最小值。所以，$3$ 从队尾出队。同理，$1$ 从队尾出队。最后 $-1$ 进队，此时 `q = {-1}`,`p = {3}`。
   
4. 出现 $-3$，同上面分析，$-1 > -3$，$-1$ 从队尾出队，$-3$ 从队尾进队。`q = {-3}`，`p = {4}`。
   
5. 出现 $5$，因为 $5 > -3$，同第二条分析，$5$ 在有生之年还是有希望的，所以 $5$ 进队。此时，`q = {-3,5}`,`p = {4,5}`。
   
6. 出现 $3$。$3$ 先与队尾的 $5$ 比较，$3 < 5$，按照第 $3$ 条的分析，$5$ 从队尾出队。$3$ 再与 $-3$ 比较，同第二条分析，$3$ 进队。此时，`q = {-3,3}`，`p = {4,6}`。
   
7. 出现 $6$。$6$ 与 $3$ 比较，因为 $3 < 6$，所以 $3$ 不必出队。由于 $3$ 以前元素都 $＜3$，所以不必再比较，$6$ 进队。因为 $-3$ 此时已经在滑动窗口之外，所以 $-3$ 从队首出队。此时，`q = {3,6}`,`p = {6,7}`。
   
8. 出现 $7$。队尾元素 $6$ 小于 $7$，$7$进队。此时，`q = {3,6,7}`,`p = {6,7,8}`。
   
那么，我们对单调队列的基本操作已经分析完毕。因为单调队列中元素大小单调递*（增 / 减 / 自定义比较），因此，队首元素必定是最值。按题意输出即可。

### Summary（Own）

单调队列本质上就是一个一定的区块，我们可以用 $head$ 和 $tail$ 去维护，$head$ 严格对应首元素，$tail$ 严格对应尾元素。  
用 `head++` 表示队首元素已经“过时”，要出队。而尾元素的进队时，可以排除尾元素 **绝对不可能出场** 的元素！也就是 **单调性** 的问题！

- 概念：$head$：一开始进队的元素；$tail$：进队的元素（接下来的元素）。

而输出，一定对应单调性一开始的最大值或最小值，也就是 $q[head]$！

#### Code（例如最小值）

```cpp
void monotone_min(){
    head = 1;
    tail = 0;//为啥要这样呢?因为head要严格对应首元素，tail要严格应尾元素，所以当tail>=head时，说明有元素。而一开始队列为空，说要这样赋值。其实这跟普通队列一样。
    for(int i = 1; i <= n; ++i){//a[i]表示当前要处理的值
        while(head <= tail && q[tail] >= a[i])
            tail--;//只要队列里有元素，并且尾元素比待处理值大，表示尾元素已经不可能出场，所以出队。直到尾元素小于待处值，满足"单调"。
        q[++tail] = a[i];//待处理值入队。
        p[tail] = i;//同时存下其编号。
        while(p[head] <= i-k)
        head++;//如果队首元素已经"过时"，出队。
        if(i >= k)printf("%d ", q[head]);//输出最值，即队首元素i>=k表示该输出，至于why就自己看题目。
    }
    printf("\n");
}
```

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long lt;
const lt N = 1e6 + 10;
lt n, k, a[N], q[N], p[N];

void min_solve(){
    lt tail = 0;
    lt head = 1;
    for(int i = 1; i <= n; i++){
        while(head <= tail && q[tail] >= a[i]) tail--;
        q[++tail] = a[i];
        p[tail] = i;
        while(p[head] <= i-k) head++;
        if(i >= k) printf("%lld ", q[head]);
    } printf("\n");
}

void max_solve(){
    lt tail = 0;
    lt head = 1;
    for(int i = 1; i <= n; i++){
        while(head <= tail && q[tail] <= a[i]) tail--;
        q[++tail] = a[i];
        p[tail] = i;
        while(p[head] <= i-k) head++;
        if(i >= k) printf("%lld ", q[head]);
    } printf("\n");
}

int main(){
    scanf("%lld%lld", &n, &k);
    for(int i = 1; i <= n; i++){
        scanf("%lld", &a[i]);
    }
    min_solve();
    max_solve();
}
```