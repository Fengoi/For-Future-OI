# 区间dp

## 石子合并

### 先假设只是一个序列（首位不相接）

`dp[l][r]`：表示区间$[l,r]$里的答案，在这个题里，就表示把$[l,r]$中的所有石子合并成一堆的最大得分

```cpp
for(int l = 1; l <= n; l++)
    for(int r = l; r <= n; r++){
    }
```

```cpp
// len表示区间里包含了几个下标
for(int len = 1; len <= n; len++)
    for(int l = 1; l <= n-len+1; l++){
        int r = l + len - 1;
    }
```

```
[1,1] [2,2] [3,3]
[1,2] [2,3]
[1,3]
```

考虑$[l,r]$是怎么合并的，考虑$[l,r]$中发生的最后一次合并，一定有某个位置$k$，我们事先已经把$[l,k]$合并好了，$[k+1,r]$也合并好了，最后一步就是把这两堆合并起来。

如果找到了这个位置$k$，那么：

$$
dp[l][r] = dp[l][k]+dp[k+1][r]
$$

```cpp
for(int i = 1; i <= n; i++)
    dp[i][i] = a[i];
// len表示区间里包含了几个下标
for(int len = 2; len <= n; len++)
    for(int l = 1; l <= n-len+1; l++){
        int r = l + len - 1;
        int sum = 0;
        for(int j = l; j <= r; j++)
            sum += a[j];
        // 如果是min：dp[l][r] = 1e9;
        for(int k = l; k < r; k++)
            dp[l][r] = max(dp[l][r], dp[l][k] + dp[k+1][r] + sum);
    }
// 最后答案就是dp[1][n]
```

```
4 4 4
8 4     得分：8
12      得分：12
总得分：20


(4 4 4) (5 9)
dp[l][k] = 20
dp[l+1][r] = 14
20 + 14 + 26
```

### 现在考虑是一个环

变成

```
4 5 9 4 4 5 9 4
```

最后答案枚举`dp[l][l+n-1]`，取max

## 关路灯

`dp[l][r][0]`：关闭编号在$[l,r]$中的所有灯，且老张的最后位置在$l$，此时的最小功耗

`dp[l][r][1]`：关闭编号在$[l,r]$中的所有灯，且老张的最后位置在$r$，此时的最小功耗

初值：`dp[c][c][0]=dp[c][c][1]=0`

更新：现在考虑区间$[l,r]$，假设最后一盏关闭的是$l$

$$
dp[l][r][0]=\min(dp[l+1][r][0]+(a[l+1]-a[l])*(\text{没关掉的灯的总功耗}),\\
dp[l+1][r][1]+(a[r]-a[l])*(\text{没关掉的灯的总功耗}))
$$

假设最后一盏关闭的是$r$

$$
dp[l][r][1]=\min(dp[l][r-1][0]+(a[r]-a[l])*(\text{没关掉的灯的总功耗}),\\
dp[l][r-1][1]+(a[r]-a[r-1])*(\text{没关掉的灯的总功耗}))
$$

如何计算没关掉的灯的总功耗？前缀和

```cpp
// p[i]：第i盏灯的功耗
sum[0] = 0;
for(int i = 1; i <= n; i++)
    sum[i] = sum[i-1] + p[i];
// sum[i]：前i盏灯的总功耗
sum[r] - sum[l-1]
// [l,r]中所有灯的总功耗
```

假设$[l,r]$中最后一盏关闭的是$l$，在去往$l$的路上，没关掉的灯包括：$[1,l]$、$[r+1,n]$，总功耗就是：

```
sum[l] + sum[n] - sum[r]
```