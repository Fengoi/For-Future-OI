# 线性基

1. 异或线性基：$\mathbb{Z}_2$ 上的线性基

2. $n$ 维实空间的线性基

## 异或线性基

给定 $n$ 个整数（数字可能重复），求在这些数中选取任意个，使得他们的异或和最大。

异或的性质：

```
a xor a = 0
a xor b = b xor a
```

我们知道有 $s$ 个数，然后我们想知道这些数通过异或（不限制几个数异或，甚至同一个数可以异或两次）可以组成哪些数字

如果有3个数：

```
0010
1000
0011
(线性基)
```

他们可以组成：

```
0000
0001
0010
0011
1000
1001
1010
1011
(线性空间)
```

我们说一组二进制数是 **“线性相关的”**，如果从中取出某几个数（每个数最多取一次），他们异或起来是0；“线性相关”的反义词就是 **“线性无关”**

我们说线性无关的一组数就是一个 **“线性基”**

线性基能表示的所有数构成一个 **“线性空间”**

如果一个线性基有 $p$ 个数，那么它对应的线性空间就有 $2^p$ 个数

如果两个不同的线性基对应的线性空间是一样的，我们就说这两个线性基 **“等价”**

```
0001
0010
1000
（上述例子的一个等价线性基）
```

任意给定 $m$ 个数，它们构成的线性空间就是它们随意异或能够表示的所有数。

我们想求出尽量少的数，使得这些数生成的线性空间和已知的 $m$ 个数是一样的。这个过程就叫做 **“求线性基”**

```
001101
001000
000101
000111
110000
（已知5个数，但它们是线性相关的，不是线性基）
```

我希望求得的线性基长成这个样子：
```
1***** P
01****
001***

100*** A
000*** B = A^P

00001*
000001
```

把 B 代替原来的 A，得到的线性基和原来是等价的。为什么？

如果我本来要异或 A，我可以先异或 B，再异或 P，就相当于异或了 A

所以原来能表示哪些数，现在还能表示哪些数

所有的线性基都能通过消去，变成“上三角型线性基”

```
****** base[5]
0***** base[4]
00**** base[3]
000*** base[2]
0000** base[1]
00000* base[0]
```

注意：每个 base 要么全是 0，要么第一个 `*` 是 1

如果已知这么一组上三角型线性基，怎么求异或最大值？

如果 `base[5]` 不是 0，那么一定要选 `base[5]`，我们记 `x=base[5]`

接下来，
- 如果 `x=*0****`，并且 `base[4]` 不是 0，那么一定要选 `base[4]`，这时候 `x=x^base[4]`
- 如果 `x=*1****`，并且 `base[4]` 不是 0，那么一定不要选 `base[4]`，这时候 `x` 还是 `x`

接下来，
- 如果 `x=**0***`，并且 `base[3]` 不是 0，那么一定要选 `base[3]`，这时候 `x=x^base[3]`
- 如果 `x=**1***`，并且 `base[3]` 不是 0，那么一定不要选 `base[3]`，这时候 `x` 还是 `x`

接下来就一样了。

```cpp
int x = 0;
for(int k = 49; k >= 0; k--){
    if( base[k] && ((x>>k)&1)==0 )
        x = x ^ base[k];
}
// 这个 x 就是 “上三角型线性基” 能异或出来的最大数
cout << x << endl;
```

对于任意给定的一组数，我们来求它的上三角型线性基。

```cpp
for(int i = 1; i <= n; i++){
    for(int k = 49; k >= 0; k--)
        if((a[i] >> k) & 1){
            if(base[k]==0){
                base[k]=a[i];
                break;
            }
            else a[i] ^= base[k];
        }
}
```

```
现在的状态：
000000
000000
001100
000000
000000
000000
有一个 a[2]=001011
它本应该被加入线性基，但看起来违背了 “上三角” 形状
我们可以异或一下再加进去
  001011
^ 001100
= 000111
我们把 000111 加进去
```

## $\mathbb{R}^n$ 中的线性基

“买下最多数量的装备的情况下花最少的钱”

改成 “买下最多数量的装备”

如果有一些 $n$ 维向量 $\mathbf{z}_1,...,\mathbf{z}_m$，有一些不全为零实数 $b_1,...,b_m$，使：
$$
b_1\mathbf{z}_1+b_2\mathbf{z}_2+...+b_m\mathbf{z}_m=\mathbf{0}
$$
我们就说 $\mathbf{z}_1,...,\mathbf{z}_m$ 是线性相关的。

“线性相关”的本质就是有某个向量能被其它向量表示。哪个向量能被表示？怎么表示？

不全为0，所以我们假设 $b_k\neq 0$，那么：
$$
b_k\mathbf{z}_k=-b_1\mathbf{z}_1-...-b_{k-1}\mathbf{z}_{k-1}-b_{k+1}\mathbf{z}_{k+1}-...-b_m\mathbf{z}_m
$$
$$
\mathbf{z}_k=-\frac{b_1}{b_k}\mathbf{z}_1-...-\frac{b_{k-1}}{b_k}\mathbf{z}_{k-1}-\frac{b_{k+1}}{b_k}\mathbf{z}_{k+1}-...-\frac{b_m}{b_k}\mathbf{z}_m
$$

我们要求出最多的向量，并且这些向量是线性无关的（一组线性无关的向量就是线性基）。

一组向量能表示出的所有向量，就是这组向量生成的 **线性空间**。

```
(0.1, 0, 0)
(0,  -1, 0)
（线性基）
```

```
(*, *, 0)
（线性空间，*表示一个任意的实数）
```

如果两组线性基生成的线性空间是一样的，我们就说这两组线性基等价。

我们说形如下面的一组线性基是“上三角线性基”
```
(* * * * * *) base[0]
(0 * * * * *) base[1]
(0 0 * * * *) base[2]
(0 0 0 * * *) base[3]
(0 0 0 0 * *) base[4]
(0 0 0 0 0 *) base[5]
```
每个 `base[i]` 都是一个 `vector<double>`。每个 `base[i]` 要么全都是 0，要么第一个 `*` 是非零实数。

所有的线性基都可以化成上三角线性基。来求线性基（一共输入 $m$ 个向量，每个向量都是 $n$ 维的）

```cpp
vector<double> base[10005], input;
input.resize(n);

for(int i = 1; i <= m; i++){
    // 读入
    for(int j = 0; j < n; j++)
        scanf("%lf", &input[j]);
    // 消元
    for(int k = 0; k < n; k++)
        if(fabs(input[k])>1e-15){
            // 这里写的 1e-15 可以换成其它很小的数
            // 但是绝对不能小于 2.3e-16
            if(base[k].empty()){
                base[k] = input;
                break;
            }
            else{
                double b = input[k]/base[k][k];
                for(int j = k; j < n; j++)
                    input[j] -= b * base[k][j];
            }
        }
}

// 输出答案（最多的装备数）
int cnt = 0;
for(int k = 0; k < n; k++)
    if(!base[k].empty()) cnt++;
cout << cnt << endl;
```

如果现在是这样的：
```
(* * * * * *) base[0]
(0 * * * * *) base[1]
(0 0 1.2 0 0 1) base[2]
(0 0 0   0 0 0) base[3]
(0 0 0   0 * *) base[4]
(0 0 0   0 0 *) base[5]
```
加入一个 `z = (0 0 0.1 1.3 0 0)`

等价于加入 `z - b * base[2]`，$b=\frac{0.1}{1.2}$

```
(0, 1.0, 0)     2    ->  加入 base[1]
(0, 1.2, 1.3)   99   ->  用 base[1] 消去，变成 (0, 0, 1.3)  -> 加入 base[2]
(0, 0, 1.4)     4    ->  用 base[2] 消去，变成全 0，然后结束了，没有加入
```

先按价格从小到大排个序就好了。

不论你按什么顺序去遍历这些向量，最后得到的线性基的 `size` 是一样的。（`size` 就是指 `base[i]` 里面非空的个数）

如果排好序之后价格是：

```
      最优     其它的
1      +
4                +
7                +
22     +         +
35     +
68
```

我最后线性基的 `size` 是 `3`，那么我总要选 3 个价格加起来。

（“其它的”是不可能的！如果“其它的”可以这么选，那在最优方案里，就算选了1，那4和7里总还有一个能选的！矛盾）

- [P3812 【模板】线性基](https://www.luogu.com.cn/problem/P3812)
- [P3265 [JLOI2015] 装备购买](https://www.luogu.com.cn/problem/P3265)
- [P4151 [WC2011] 最大XOR和路径](https://www.luogu.com.cn/problem/P4151)
- [P4301 [CQOI2013] 新Nim游戏](https://www.luogu.com.cn/problem/P4301)