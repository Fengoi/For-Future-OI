# 最长上升子序列(Longest Incresing Subsequence, LIS)

给你$n$个数，分别为$a_1,...,a_n$，在里面选一些数，不一定要连着选，但选出来的数必须是（不严格）递增的。问：最多能选几个数？

1. $n\leq 1000$
2. $n\leq 10^6$

## 两层循环

```cpp
// dp[i]表示以i结尾的最长上升子序列
for(int i = 1; i <= n; i++){
    for(int j = 1; j < i; j++){
        if(a[i] >= a[j]) dp[i] = max(dp[i], dp[j]);
    }
    dp[i]++;
}
// 答案对dp[1],....,dp[n]取max
```

## 更优的做法

### 二分查找

给定一个单调上升的序列$b_1,...,b_p$，在里面找最大的不超过$x$的数

```cpp
int l=1, r=p, mid;
while(l < r){
    mid = (l+r) / 2;
    if(b[mid] > x) r = mid-1;
    else l = mid;
}
// 最后b[l]就是答案
```

我们一般不用这个，用现成的：

```cpp
    // 返回的是最小的大于等于x的数的下标
    int l = lower_bound(b+1, b+1+p, x) - b;
    if(b[l]==x) return b[l];
    else return b[l-1];
```

```cpp
    // 返回的是最小的大于x的数的下标
    int l = upper_bound(b+1, b+1+p, x) - b;
```

### 一个$O(n\log n)$的LIS算法

设`d[c]`表示长度为$c$的LIS结尾的数字最小是多少

```
1 8 3 7 94
d[1] = 1
d[2] = 3
d[3] = 7
d[4] = 94
```

数组`d`一定是递增的，为什么？

```cpp
for(int i = 1; i <= n; i++){
    // d[c]表示截止到第i个数之前，长度为c的LIS结尾的数字最小是多少
    // L表示截止到第i个数之前，LIS的长度
    // 更新d[c]
    if(a[i] >= d[L]){
        L++;
        d[L] = a[i];
    } else {
        int l = upper_bound(d+1, d+1+L, a[i]) - d;
        d[l] = a[i];
    }
    // 此时，d[c]表示截止到第i个数之后，长度为c的LIS结尾的数字最小是多少
}
// 最后L就是答案
```

```
1 8 3 7 94
现在i=3，开始进入循环
   d[1]=1, d[2]=8
我们现在要把d[2]变成3
```

```
1 3 7 8 6 6 7
现在i=5，开始进入循环
   d[1]=1, d[2]=3, d[3]=7, d[4]=8, L=4
我们现在要把d[3]变成6
（寻找d里面第一个大于6的数）
现在i=6，开始进入循环
   d[1]=1, d[2]=3, d[3]=6, d[4]=8, L=4
（寻找d里面第一个大于6的数）
现在i=7，开始进入循环
   d[1]=1, d[2]=3, d[3]=6, d[4]=6, L=4
```

### 复杂度里的$\log$

一般默认以$2$为底，但不重要，因为：

$$
\log_3 n = \frac{\log_2 n}{\log_2 3}
$$